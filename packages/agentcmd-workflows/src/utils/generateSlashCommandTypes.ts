import type { CommandDefinition } from '../types/slash-commands-internal';
import { writeFile, mkdir } from 'fs/promises';
import path from 'path';
import { generateResponseTypeCode, commandNameToTypeName, commandNameToArgsTypeName } from './generateCommandResponseTypes';

/**
 * Check if a property name needs quotes in TypeScript
 * @param name - Property name to check
 * @returns True if the name needs quotes
 */
function needsQuotes(name: string): boolean {
  // Check if name is a valid JavaScript identifier
  // Valid identifiers: start with letter/underscore/$, followed by letters/digits/underscores/$
  return !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name);
}

/**
 * Generate TypeScript Args interface for a command
 *
 * @param cmd - Command definition
 * @returns Generated TypeScript interface as a string
 */
function generateArgsTypeCode(cmd: CommandDefinition): string {
  const typeName = commandNameToArgsTypeName(cmd.name);

  if (cmd.arguments.length === 0) {
    return `/**\n * Args type for ${cmd.name} command (no arguments)\n */\nexport interface ${typeName} {}\n`;
  }

  let result = `/**\n * Args type for ${cmd.name} command\n */\n`;
  result += `export interface ${typeName} {\n`;

  for (const arg of cmd.arguments) {
    const optional = arg.required ? '' : '?';
    const propName = needsQuotes(arg.name) ? `"${arg.name}"` : arg.name;
    result += `  ${propName}${optional}: string;\n`;
  }

  result += '}\n';
  return result;
}

/**
 * Generate TypeScript code from command definitions
 *
 * @param commands - Array of parsed command definitions
 * @returns Generated TypeScript code as a string
 */
export function generateSlashCommandTypesCode(commands: CommandDefinition[]): string {
  if (commands.length === 0) {
    return `// Auto-generated by workflow-sdk generate-slash-types
// No commands found

export type SlashCommandName = never;
export type SlashCommandArgs = Record<string, never>;

export function buildSlashCommand(): string {
  throw new Error("No slash commands available");
}
`;
  }

  // Generate command name union type
  const commandNames = commands.map((cmd) => `"${cmd.name}"`).join(' | ');

  // Generate args interface mapping
  const argsMapping = commands
    .map((cmd) => {
      if (cmd.arguments.length === 0) {
        return `  "${cmd.name}": Record<string, never>;`;
      }

      const argTypes = cmd.arguments
        .map((arg) => {
          const optional = arg.required ? '' : '?';
          // Quote property names to handle kebab-case
          return `"${arg.name}"${optional}: string`;
        })
        .join('; ');

      return `  "${cmd.name}": { ${argTypes} };`;
    })
    .join('\n');

  // Generate argument order constant
  const argOrderMapping = commands
    .map((cmd) => {
      const argNames = cmd.arguments.map((arg) => `"${arg.name}"`).join(', ');
      return `  "${cmd.name}": [${argNames}]`;
    })
    .join(',\n');

  // Generate buildSlashCommand implementation
  const buildFunction = `/**
 * Build a type-safe slash command string
 *
 * @param name - Command name (e.g., "/generate-prd")
 * @param args - Command arguments object
 * @returns Formatted command string with escaped quotes
 *
 * @example
 * buildSlashCommand("/generate-prd", { featureName: "auth", context: "Add OAuth" })
 * // Returns: "/generate-prd 'auth' 'Add OAuth'"
 */
export function buildSlashCommand<T extends SlashCommandName>(
  name: T,
  args?: SlashCommandArgs[T]
): string {
  const parts: string[] = [name];
  const argOrder = SlashCommandArgOrder[name];

  // Add arguments in frontmatter order
  if (args && typeof args === "object" && argOrder) {
    for (const argName of argOrder) {
      const value = (args as Record<string, unknown>)[argName];
      // Skip undefined values (optional arguments)
      if (value !== undefined && value !== null) {
        // Escape single quotes in the value
        const escaped = String(value).replace(/'/g, "\\\\'");
        parts.push(\`'\${escaped}'\`);
      }
    }
  }

  return parts.join(" ");
}`;

  // Generate individual Args type interfaces
  const argsTypes = commands
    .map((cmd) => generateArgsTypeCode(cmd))
    .join('\n');

  // Generate response type interfaces
  const responseTypes = commands
    .filter((cmd) => cmd.responseSchema)
    .map((cmd) => generateResponseTypeCode(cmd.name, cmd.responseSchema!))
    .join('\n');

  // Generate SlashCommandResponses mapping
  const responsesMapping = commands
    .filter((cmd) => cmd.responseSchema)
    .map((cmd) => {
      const typeName = commandNameToTypeName(cmd.name);
      return `  "${cmd.name}": ${typeName};`;
    })
    .join('\n');

  const responsesInterface = responsesMapping
    ? `/**\n * Mapping of slash commands to their JSON response types\n */\nexport interface SlashCommandResponses {\n${responsesMapping}\n}`
    : '';

  // Combine all parts
  return `// Auto-generated by workflow-sdk generate-slash-types
// Do not edit this file manually

/**
 * Union type of all available slash command names
 */
export type SlashCommandName = ${commandNames};

/**
 * Mapping of command names to their argument types
 */
export interface SlashCommandArgs {
${argsMapping}
}

/**
 * Mapping of command names to their argument order from frontmatter
 * Preserves positional argument order regardless of object property order
 */
export const SlashCommandArgOrder = {
${argOrderMapping}
} as const;

${buildFunction}

// Individual Args type interfaces
${argsTypes}
${responseTypes ? '// Response type interfaces\n' + responseTypes : ''}${responsesInterface ? '\n' + responsesInterface : ''}
`;
}

/**
 * Convenience wrapper that orchestrates parse → generate → write
 *
 * @param inputDir - Directory containing .claude/commands/*.md files
 * @param outputPath - Path to write generated TypeScript file
 */
export async function generateSlashCommandTypesFromDir(inputDir: string, outputPath: string): Promise<void> {
  const { parseSlashCommands } = await import('./parseSlashCommands');

  // Parse commands
  const commands = await parseSlashCommands(inputDir);

  // Generate code
  const code = generateSlashCommandTypesCode(commands);

  // Ensure output directory exists
  const outputDir = path.dirname(outputPath);
  await mkdir(outputDir, { recursive: true });

  // Write to file
  await writeFile(outputPath, code, 'utf-8');
}
