/**
 * Execute Gemini CLI commands.
 *
 * Command Structure:
 * gemini --output-format stream-json --approval-mode auto_edit "prompt"
 *
 * Permission Mode Mapping:
 * - default → --approval-mode default
 * - acceptEdits → --approval-mode auto_edit
 * - bypassPermissions → --yolo
 *
 * Note: Streaming format differs from session file format.
 * This implementation handles the streaming JSONL output from the CLI.
 *
 * ⚠️ Session Management Limitation:
 * Gemini CLI does NOT support session resumption via CLI flags.
 * Each invocation creates a new session ID automatically.
 * Sessions are stored in ~/.gemini/tmp/<project-hash>/ but cannot be resumed.
 */

import type { UnifiedMessage } from '../types/unified';
import type { PermissionMode } from '../types/permissions';
import { spawnProcess } from '../utils/spawn';
import { extractJSON } from '../utils/extractJson';
import { detectCli } from './detectCli';

// ============================================================================
// Types
// ============================================================================

/**
 * Options for executing a Gemini CLI command.
 */
export interface ExecuteOptions {
  /** The prompt/instruction to send to Gemini */
  prompt: string;
  /** Working directory for command execution (defaults to current directory) */
  workingDir?: string;
  /** Timeout in milliseconds (defaults to 5 minutes) */
  timeout?: number;
  /** Enable verbose output logging */
  verbose?: boolean;
  /**
   * Session identifier (for tracking purposes only).
   * Note: Gemini CLI does not support session resumption.
   * A new session ID is generated by Gemini on each invocation.
   */
  sessionId?: string;
  /**
   * Resume an existing session (NOT SUPPORTED by Gemini CLI).
   * This option is ignored - included for API compatibility only.
   * @deprecated Gemini CLI does not support session resumption
   */
  resume?: boolean;
  /** Gemini model to use */
  model?: string;
  /** Permission mode for file operations and command execution */
  permissionMode?: PermissionMode;
  /** Automatically extract and parse JSON from the response */
  json?: boolean;
  /** Callback invoked with raw stdout data */
  onStdout?: (chunk: string) => void;
  /** Callback invoked when stderr data is received */
  onStderr?: (chunk: string) => void;
  /** Callback invoked when an error occurs */
  onError?: (error: Error) => void;
  /** Callback invoked when the process closes */
  onClose?: (exitCode: number) => void;
}

/**
 * Result of executing a Gemini CLI command.
 * @template T - Type of the extracted data (string by default, or parsed JSON type)
 */
export interface ExecuteResult<T = string> {
  /** Whether the command completed successfully */
  success: boolean;
  /** Exit code from the CLI process */
  exitCode: number;
  /** Session identifier for this execution */
  sessionId: string;
  /** Duration of execution in milliseconds */
  duration: number;
  /** All messages exchanged during execution */
  messages: UnifiedMessage[];
  /** Extracted data (text or parsed JSON) */
  data: T;
  /** Error message if execution failed */
  error?: string;
}

// ============================================================================
// Public Functions
// ============================================================================

/**
 * Execute a Gemini CLI command and return the complete result.
 *
 * @template T - Type of the extracted data (defaults to string, specify for JSON extraction)
 * @param options - Execution options including prompt, callbacks, and settings
 * @returns Promise resolving to the execution result with messages and data
 * @throws {Error} If Gemini CLI is not found
 */
export async function execute<T = string>(options: ExecuteOptions): Promise<ExecuteResult<T>> {
  const cliPath = await detectCli();
  if (!cliPath) {
    throw new Error('Gemini CLI not found. Set GEMINI_CLI_PATH or install Gemini CLI.');
  }

  const args = buildArgs(options);

  // Use provided sessionId or generate a new one
  const sessionId = options.sessionId || generateSessionId();

  // Spawn process
  const messages: UnifiedMessage[] = [];
  let rawOutput = '';
  let stderr = '';
  let geminiSessionId: string | undefined;
  const startTime = Date.now();

  try {
    const result = await spawnProcess(cliPath, {
      args,
      cwd: options.workingDir,
      timeout: options.timeout || 300000, // 5 minutes default
      verbose: options.verbose,
      onStdout: (chunk) => {
        rawOutput += chunk;

        // Try to extract session_id from init event
        if (!geminiSessionId) {
          const initMatch = chunk.match(/"type":"init"[^}]*"session_id":"([^"]+)"/);
          if (initMatch) {
            geminiSessionId = initMatch[1];
          }
        }

        options.onStdout?.(chunk);
      },
      onStderr: (chunk) => {
        stderr += chunk;
        options.onStderr?.(chunk);
      },
      onError: (error) => {
        options.onError?.(error);
      },
      onClose: (exitCode) => {
        options.onClose?.(exitCode);
      },
    });

    const success = result.exitCode === 0;
    const isQuotaError = stderr.includes('Quota exceeded') || stderr.includes('RATE_LIMIT_EXCEEDED');

    return {
      success,
      exitCode: result.exitCode,
      sessionId: geminiSessionId || sessionId, // Use Gemini's session ID if available
      duration: result.duration,
      messages,
      data: extractData<T>(options, rawOutput) as T,
      error: success ? undefined : isQuotaError ? 'Quota exceeded - rate limit reached' : stderr || 'Command failed',
    };
  } catch (error) {
    // Handle timeout and other errors gracefully
    const duration = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    const isQuotaError = stderr.includes('Quota exceeded') || stderr.includes('RATE_LIMIT_EXCEEDED');

    return {
      success: false,
      exitCode: -1,
      sessionId: geminiSessionId || sessionId, // Use Gemini's session ID if available
      duration,
      messages,
      data: extractData<T>(options, rawOutput) as T,
      error: isQuotaError ? 'Quota exceeded - rate limit reached' : stderr || errorMessage,
    };
  }
}

// ============================================================================
// Private Functions
// ============================================================================

/**
 * Generate a unique session ID
 */
function generateSessionId(): string {
  return `gemini-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
}

/**
 * Build CLI arguments from execution options
 */
function buildArgs(options: ExecuteOptions): string[] {
  const args: string[] = [];

  // Output format
  args.push('--output-format', 'stream-json');

  // Note: Gemini CLI does not support --session-id or --resume flags
  // Each invocation creates a new session automatically
  // options.sessionId and options.resume are ignored

  // Permission mode
  if (options.permissionMode) {
    switch (options.permissionMode) {
      case 'default':
        args.push('--approval-mode', 'default');
        break;
      case 'plan':
        args.push('--approval-mode', 'default'); // Read-only mode
        break;
      case 'acceptEdits':
        args.push('--approval-mode', 'auto_edit');
        break;
      case 'bypassPermissions':
        args.push('--yolo');
        break;
    }
  }

  // Model
  if (options.model) {
    args.push('--model', options.model);
  }

  // Prompt (last argument)
  args.push(options.prompt);

  return args;
}

/**
 * Extract data from output based on options
 */
function extractData<T>(options: ExecuteOptions, output: string): T | string {
  if (options.json) {
    // Extract assistant message content from JSONL output
    const assistantContent = extractAssistantContent(output);
    if (assistantContent) {
      const extracted = extractJSON(assistantContent);
      return (extracted || assistantContent) as T | string;
    }
    // Fallback to extracting from full output
    const extracted = extractJSON(output);
    return (extracted || output) as T | string;
  }

  return output as T | string;
}

/**
 * Extract assistant message content from JSONL output
 */
function extractAssistantContent(output: string): string | null {
  const lines = output.split('\n').filter((line) => line.trim());

  for (const line of lines) {
    try {
      const parsed = JSON.parse(line);
      // Look for assistant messages with content
      if (parsed.type === 'message' && parsed.role === 'assistant' && parsed.content) {
        return parsed.content;
      }
    } catch {
      // Skip invalid JSON lines
      continue;
    }
  }

  return null;
}
