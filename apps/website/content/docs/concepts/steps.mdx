---
title: Steps
description: 8 step types for building workflows
---

import { Card, Cards } from 'fumadocs-ui/components/card';
import { AgentCmd } from '@/components/AgentCmd';

Steps are the building blocks of workflows. <AgentCmd /> provides 8 step types to handle different automation tasks.

## Step Types Overview

| Step Type | Purpose | Timeout | Reference |
|-----------|---------|---------|-----------|
| **agent** | Run AI CLI tools (Claude, Codex, Gemini) | 30 min | [Learn more →](/docs/reference/steps/agent) |
| **ai** | Non-interactive AI text/structured generation | 5 min | [Learn more →](/docs/reference/steps/ai) |
| **bash** | Execute shell commands | 5 min | [Learn more →](/docs/reference/steps/bash) |
| **git** | Git operations (commit, branch, PR) | 2 min | [Learn more →](/docs/reference/steps/git) |
| **artifact** | Upload files/images/directories | 5 min | [Learn more →](/docs/reference/steps/artifact) |
| **annotation** | Progress notes for timeline | Instant | [Learn more →](/docs/reference/steps/annotation) |
| **phase** | Group related steps | N/A | [Learn more →](/docs/reference/steps/phase) |
| **webhook** | Send HTTP webhooks | 5 min | [Learn more →](/docs/reference/steps/webhook) |

**Note:** The quick examples below show common uses. Click "Learn more" for complete API documentation.

## Quick Examples

### Agent Step

Run AI CLI tools with full file access:

```typescript
await step.agent("implement-feature", {
  agent: "claude",
  prompt: "Implement user authentication system",
  workingDir: "/path/to/project",
  permissionMode: "acceptEdits", // Auto-approve file edits
});
```

**When to use**: Complex tasks requiring file editing, multiple iterations, tool use

### AI Step

Fast AI text or structured generation:

```typescript
const analysis = await step.ai("analyze-code", {
  prompt: "Analyze this codebase for security issues",
  provider: "anthropic",
  schema: z.object({
    issues: z.array(z.object({
      severity: z.enum(["high", "medium", "low"]),
      description: z.string(),
    })),
  }),
});
```

**When to use**: Quick AI responses, structured data extraction, no file editing needed

### Bash Step

Execute shell commands:

```typescript
await step.bash("run-tests", {
  command: "pnpm test --coverage",
  cwd: projectPath,
  env: { NODE_ENV: "test" },
});
```

**When to use**: Build, test, deploy, any shell command

### Git Step

Git operations:

```typescript
await step.git("create-feature-branch", {
  operation: "commit-and-branch",
  commitMessage: "feat: Add user authentication",
  branch: "feat/auth-system",
});
```

**When to use**: Commit changes, create branches, open PRs

### Artifact Step

Upload outputs for review:

```typescript
await step.artifact("test-results", {
  name: "coverage-report.html",
  type: "file",
  file: "./coverage/index.html",
  description: "Test coverage report",
});
```

**When to use**: Save build outputs, reports, images, generated files

### Annotation Step

Mark progress in timeline:

```typescript
await step.annotation("planning-complete", {
  message: "Feature design complete ✓ Starting implementation...",
});
```

**When to use**: Explain what's happening, mark phase transitions, celebrate wins

### Phase Step

Organize related steps:

```typescript
await step.phase("test", async () => {
  await step.bash("unit", { command: "pnpm test:unit" });
  await step.bash("e2e", { command: "pnpm test:e2e" });
});
```

**When to use**: Group steps into logical stages (plan, build, test, deploy)

### Log Step

Debug and tracking:

```typescript
step.log("Starting deployment...");
step.log.warn("API rate limit approaching");
step.log.error("Deployment failed", error);
```

**When to use**: Development, debugging, monitoring

## Step Execution Model

### Sequential by Default

Steps run one after another:

```typescript
await step.bash("step-1", { ... });  // Runs first
await step.bash("step-2", { ... });  // Then this
await step.bash("step-3", { ... });  // Finally this
```

### Parallel with Promise.all()

Run steps concurrently:

```typescript
await Promise.all([
  step.bash("lint", { command: "pnpm lint" }),
  step.bash("test", { command: "pnpm test" }),
  step.bash("typecheck", { command: "pnpm check-types" }),
]);
```

**All three run simultaneously**

### Conditional Execution

Skip steps based on logic:

```typescript
if (needsSetup) {
  await step.bash("setup", { command: "pnpm install" });
}

await step.bash("build", { command: "pnpm build" });

if (shouldDeploy) {
  await step.git("deploy", { operation: "commit" });
}
```

## Step Return Values

Most steps return results:

### Agent Step Returns

```typescript
const result = await step.agent("code", {
  agent: "claude",
  json: true, // Extract JSON from response
  prompt: "Generate API spec",
});

// result.data contains extracted JSON
console.log(result.data.endpoints);
```

### AI Step Returns

```typescript
const analysis = await step.ai("analyze", {
  prompt: "Analyze code quality",
  schema: mySchema,
});

// Typed result based on schema
analysis.data.score; // Type-safe!
```

### Bash Step Returns

```typescript
const output = await step.bash("version", {
  command: "node --version",
});

console.log(output.stdout); // "v18.17.0"
console.log(output.exitCode); // 0
```

## Error Handling

### Try/Catch

Handle step failures:

```typescript
try {
  await step.bash("deploy", {
    command: "deploy-to-prod",
  });
} catch (error) {
  await step.annotation("deploy-failed", {
    message: `Deployment failed: ${error}. Rolling back...`,
  });

  await step.bash("rollback", {
    command: "rollback-deployment",
  });
}
```

### Timeout Configuration

Override default timeouts:

```typescript
await step.bash("long-build", {
  command: "pnpm build",
}, {
  timeout: 600000, // 10 minutes
});
```

## Step Naming

**Each step must have a unique name.** Use descriptive, action-oriented names:

✅ **Good**:
```typescript
await step.bash("install-dependencies", { ... });
await step.agent("implement-authentication", { ... });
await step.git("create-feature-branch", { ... });
```

❌ **Bad** - Generic/duplicate names:
```typescript
await step.bash("step1", { ... });
await step.agent("do-stuff", { ... });
await step.bash("run-command", { ... }); // Too generic
await step.bash("run-command", { ... }); // Duplicate!
```

**Why unique names matter**:
- Steps are tracked by name in Inngest
- Duplicate names cause workflow errors
- Names appear in Timeline UI, logs, error messages
- Make them clear and searchable

## Next Steps

<Cards>
  <Card title="Agent Step Reference" href="/docs/reference/steps/agent">
    Complete API for agent steps
  </Card>
  <Card title="All Step Types" href="/docs/reference/steps">
    Detailed docs for all 8 step types
  </Card>
  <Card title="Workflow Examples" href="/docs/examples">
    Real workflows using steps
  </Card>
  <Card title="Error Handling" href="/docs/guides/error-handling">
    Handle failures gracefully
  </Card>
</Cards>
