---
title: Context Sharing
description: Share data between phases using JavaScript closures
---

import { Callout } from 'fumadocs-ui/components/callout';
import { AgentCmd } from '@/components/AgentCmd';

## Overview

Workflows often need to pass data from one phase to another (e.g., a spec file path from planning to implementation). <AgentCmd /> uses **JavaScript closures** for context sharing—simple, type-safe, and no special APIs needed.

## Basic Pattern

Define a context object before your phases, then mutate it within steps:

```typescript
export default defineWorkflow(
  {
    id: "my-workflow",
    phases: ["plan", "implement"],
  },
  async ({ event, step }) => {
    // Shared context via closure
    interface Context {
      specFile?: string;
      branch?: string;
    }
    const ctx: Context = {};

    await step.phase("plan", async () => {
      const result = await step.agent("generate-spec", {
        agent: "claude",
        prompt: "Create implementation spec",
      });

      // Store result in context
      ctx.specFile = result.data;
    });

    await step.phase("implement", async () => {
      // Access context from previous phase
      if (!ctx.specFile) {
        throw new Error("No spec file generated");
      }

      await step.agent("implement", {
        agent: "claude",
        prompt: `Implement spec: ${ctx.specFile}`,
      });
    });
  }
);
```

## Why Closures?

<Callout type="info">
**JavaScript closures are perfect for workflow context:**

- Type-safe with TypeScript interfaces
- No serialization overhead (stays in memory)
- Simple and familiar JavaScript pattern
- Zero learning curve
</Callout>

Alternative approaches (like Inngest's `step.run()` return values) require serialization and lose type safety across phases. Closures keep everything in-memory and fully typed.

## Typed Context

Define an interface for your context to get autocomplete and type checking:

```typescript
interface WorkflowContext {
  specFile?: string;
  branch?: string;
  buildArtifacts?: string[];
  testResults?: {
    passed: number;
    failed: number;
  };
}

export default defineWorkflow(
  {
    id: "build-test-deploy",
    phases: ["build", "test", "deploy"],
  },
  async ({ event, step }) => {
    const ctx: WorkflowContext = {};

    await step.phase("build", async () => {
      const buildResult = await step.cli("build", {
        command: "npm run build",
      });

      ctx.buildArtifacts = ["dist/app.js", "dist/styles.css"];
    });

    await step.phase("test", async () => {
      const testResult = await step.cli("test", {
        command: "npm test",
      });

      ctx.testResults = {
        passed: 45,
        failed: 0,
      };
    });

    await step.phase("deploy", async () => {
      // Type-safe access
      if (!ctx.testResults || ctx.testResults.failed > 0) {
        throw new Error("Cannot deploy with failing tests");
      }

      await step.cli("deploy", {
        command: "npm run deploy",
      });
    });

    return {
      success: true,
      context: ctx, // Return full context in workflow result
    };
  }
);
```

## Accumulating Data

Build up context progressively across phases:

```typescript
interface BuildContext {
  files: string[];
  warnings: string[];
  metadata: Record<string, unknown>;
}

export default defineWorkflow(
  {
    id: "progressive-build",
    phases: ["lint", "build", "package"],
  },
  async ({ event, step }) => {
    const ctx: BuildContext = {
      files: [],
      warnings: [],
      metadata: {},
    };

    await step.phase("lint", async () => {
      await step.cli("lint", {
        command: "npm run lint",
      });

      // Add to context
      ctx.warnings.push("Unused variable in utils.ts");
      ctx.metadata.lintDuration = 1200;
    });

    await step.phase("build", async () => {
      await step.cli("build", {
        command: "npm run build",
      });

      // Continue adding
      ctx.files.push("dist/app.js", "dist/vendor.js");
      ctx.metadata.buildDuration = 3400;
    });

    await step.phase("package", async () => {
      // Use accumulated context
      await step.artifact("build-manifest", {
        name: "manifest.json",
        type: "text",
        content: JSON.stringify({
          files: ctx.files,
          warnings: ctx.warnings,
          metadata: ctx.metadata,
        }, null, 2),
      });
    });

    return { success: true, files: ctx.files.length };
  }
);
```

## Conditional Flow

Use context to make decisions about which steps to run:

```typescript
interface ChangeContext {
  hasBackendChanges: boolean;
  hasFrontendChanges: boolean;
  hasDbMigrations: boolean;
}

export default defineWorkflow(
  {
    id: "smart-deploy",
    phases: ["analyze", "build", "deploy"],
  },
  async ({ event, step }) => {
    const ctx: ChangeContext = {
      hasBackendChanges: false,
      hasFrontendChanges: false,
      hasDbMigrations: false,
    };

    await step.phase("analyze", async () => {
      const diffResult = await step.cli("check-changes", {
        command: "git diff --name-only HEAD~1",
      });

      // Analyze changes
      const files = diffResult.stdout?.split("\n") || [];
      ctx.hasBackendChanges = files.some(f => f.startsWith("src/server/"));
      ctx.hasFrontendChanges = files.some(f => f.startsWith("src/client/"));
      ctx.hasDbMigrations = files.some(f => f.includes("migrations/"));
    });

    await step.phase("build", async () => {
      if (ctx.hasFrontendChanges) {
        await step.cli("build-frontend", {
          command: "npm run build:client",
        });
      }

      if (ctx.hasBackendChanges) {
        await step.cli("build-backend", {
          command: "npm run build:server",
        });
      }
    });

    await step.phase("deploy", async () => {
      if (ctx.hasDbMigrations) {
        await step.cli("migrate", {
          command: "npm run db:migrate",
        });
      }

      if (ctx.hasBackendChanges) {
        await step.cli("deploy-backend", {
          command: "npm run deploy:server",
        });
      }

      if (ctx.hasFrontendChanges) {
        await step.cli("deploy-frontend", {
          command: "npm run deploy:client",
        });
      }
    });
  }
);
```

## Step Results

Store step results in context for later use:

```typescript
interface StepResults {
  agentSessionId?: string;
  commitSha?: string;
  prNumber?: number;
}

export default defineWorkflow(
  {
    id: "feature-workflow",
    phases: ["plan", "implement", "pr"],
  },
  async ({ event, step }) => {
    const ctx: StepResults = {};

    await step.phase("plan", async () => {
      const result = await step.agent("plan-feature", {
        agent: "claude",
        prompt: "Plan the feature",
      });

      // Store agent session for resumption
      ctx.agentSessionId = result.sessionId;
    });

    await step.phase("implement", async () => {
      const result = await step.agent("implement-feature", {
        agent: "claude",
        prompt: "Implement the feature",
        resume: ctx.agentSessionId, // Resume from planning session
      });

      // Commit the changes
      const gitResult = await step.git("commit", {
        operation: "commit",
        message: "feat: implement feature",
      });

      ctx.commitSha = gitResult.sha;
    });

    await step.phase("pr", async () => {
      const prResult = await step.git("create-pr", {
        operation: "pr",
        title: "Add new feature",
        body: `Implemented feature\n\nCommit: ${ctx.commitSha}`,
        branch: "feature/new",
        baseBranch: "main",
      });

      ctx.prNumber = prResult.number;
    });

    return {
      success: true,
      pr: ctx.prNumber,
      commit: ctx.commitSha,
    };
  }
);
```

## Best Practices

### Initialize Context Early

Define your context interface and initialize the object before any phases:

```typescript
// ✅ Good
async ({ event, step }) => {
  interface Context { ... }
  const ctx: Context = {};

  await step.phase("phase1", async () => { ... });
}

// ❌ Avoid - context defined inside phase
async ({ event, step }) => {
  await step.phase("phase1", async () => {
    const ctx = {}; // Not accessible in other phases!
  });
}
```

### Use Optional Properties

Context properties should be optional (`?`) since they're populated during execution:

```typescript
// ✅ Good
interface Context {
  specFile?: string;
  branch?: string;
}

// ❌ Avoid - required properties cause type errors
interface Context {
  specFile: string; // Type error: not initialized
  branch: string;
}
```

### Validate Before Use

Check that required context exists before accessing:

```typescript
await step.phase("implement", async () => {
  if (!ctx.specFile) {
    throw new Error("Missing spec file from plan phase");
  }

  // Safe to use ctx.specFile
});
```

### Keep Context Serializable

If you return context in workflow results, keep it JSON-serializable:

```typescript
// ✅ Good
interface Context {
  files: string[];
  count: number;
  metadata: Record<string, string>;
}

// ❌ Avoid - not serializable
interface Context {
  files: string[];
  callback: () => void; // Functions can't be serialized
  date: Date; // Dates lose type in JSON
}
```

## Next Steps

- [Error Handling](/docs/guides/error-handling) - Handle context validation failures
- [Workflow Definition](/docs/guides/workflow-definition) - Back to basics
- [Phases](/docs/concepts/phases) - Learn more about phase organization
