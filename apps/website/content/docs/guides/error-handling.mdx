---
title: Error Handling
description: Handle failures gracefully with try/catch, retries, and recovery
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

## Overview

Workflow steps can fail for many reasons: network timeouts, command failures, validation errors, etc. AgentCmd provides multiple strategies for handling failures:

- **Try/catch blocks** - Handle errors at the phase level
- **Step retries** - Automatic retry with configurable timeout
- **Error artifacts** - Capture error details for debugging
- **Graceful degradation** - Continue workflow despite failures

## Basic Error Handling

Steps automatically throw on failure. Use try/catch to handle errors:

```typescript
export default defineWorkflow(
  {
    id: "my-workflow",
    phases: ["build"],
  },
  async ({ event, step }) => {
    await step.phase("build", async () => {
      try {
        await step.cli("build", {
          command: "npm run build",
        });

        await step.annotation("build-success", {
          message: "Build completed successfully",
        });
      } catch (error) {
        await step.annotation("build-failed", {
          message: `Build failed: ${error}`,
        });

        // Re-throw to fail the phase
        throw error;
      }
    });
  }
);
```

## Step Timeouts

All step methods accept a `timeout` option (in milliseconds):

```typescript
// Default timeouts by step type:
// - agent: 30 min (1,800,000ms)
// - cli: 5 min (300,000ms)
// - git: 2 min (120,000ms)
// - ai: 5 min (300,000ms)
// - artifact: 5 min (300,000ms)

// Custom timeout
await step.cli("long-build", {
  command: "npm run build",
}, {
  timeout: 600000, // 10 minutes
});

// Short timeout
await step.cli("quick-check", {
  command: "npm run lint",
}, {
  timeout: 30000, // 30 seconds
});
```

<Callout type="warn">
**Timeout Errors**: When a step times out, it throws an error that can be caught with try/catch.
</Callout>

## Retry Pattern

Use `step.run()` with manual retry logic:

```typescript
async function retryStep<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  delayMs: number = 1000
): Promise<T> {
  let lastError: Error | unknown;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      if (i < maxRetries - 1) {
        await step.sleep(`retry-delay-${i}`, `${delayMs}ms`);
      }
    }
  }

  throw lastError;
}

// Usage
await step.phase("build", async () => {
  await retryStep(
    async () => step.cli("build", { command: "npm run build" }),
    3,  // max 3 retries
    2000 // 2 second delay
  );
});
```

<Tabs items={['Simple Retry', 'Exponential Backoff', 'With Context']}>
  <Tab value="Simple Retry">
    ```typescript
    await step.phase("deploy", async () => {
      let attempts = 0;
      const maxAttempts = 3;

      while (attempts < maxAttempts) {
        try {
          await step.cli("deploy", {
            command: "npm run deploy",
          });
          break; // Success, exit loop
        } catch (error) {
          attempts++;
          if (attempts >= maxAttempts) {
            throw error; // Final attempt failed
          }

          await step.annotation("retry", {
            message: `Deploy failed, retrying (${attempts}/${maxAttempts})`,
          });

          await step.sleep(`retry-${attempts}`, "5s");
        }
      }
    });
    ```
  </Tab>

  <Tab value="Exponential Backoff">
    ```typescript
    await step.phase("api-call", async () => {
      let attempts = 0;
      const maxAttempts = 5;

      while (attempts < maxAttempts) {
        try {
          await step.cli("api-call", {
            command: "curl https://api.example.com/data",
          });
          break;
        } catch (error) {
          attempts++;
          if (attempts >= maxAttempts) {
            throw error;
          }

          // Exponential backoff: 2^attempts seconds
          const delaySeconds = Math.pow(2, attempts);

          await step.annotation("backoff", {
            message: `API call failed, backing off ${delaySeconds}s`,
          });

          await step.sleep(`backoff-${attempts}`, `${delaySeconds}s`);
        }
      }
    });
    ```
  </Tab>

  <Tab value="With Context">
    ```typescript
    interface RetryContext {
      attempts: number;
      errors: string[];
    }

    export default defineWorkflow(
      { id: "retry-workflow", phases: ["execute"] },
      async ({ event, step }) => {
        const ctx: RetryContext = {
          attempts: 0,
          errors: [],
        };

        await step.phase("execute", async () => {
          const maxAttempts = 3;

          while (ctx.attempts < maxAttempts) {
            try {
              await step.cli("flaky-command", {
                command: "npm run test:e2e",
              });
              break; // Success
            } catch (error) {
              ctx.attempts++;
              ctx.errors.push(String(error));

              if (ctx.attempts >= maxAttempts) {
                // Create error artifact with all attempts
                await step.artifact("retry-log", {
                  name: "retry-errors.json",
                  type: "text",
                  content: JSON.stringify(ctx, null, 2),
                });
                throw error;
              }

              await step.sleep(`retry-${ctx.attempts}`, "3s");
            }
          }
        });

        return { success: true, attempts: ctx.attempts };
      }
    );
    ```
  </Tab>
</Tabs>

## Error Artifacts

Capture error details for debugging:

```typescript
await step.phase("build", async () => {
  try {
    await step.cli("build", {
      command: "npm run build",
    });
  } catch (error) {
    // Create error artifact
    await step.artifact("build-error", {
      name: "build-error.log",
      type: "text",
      content: `Build Error
============
Time: ${new Date().toISOString()}
Error: ${String(error)}
Stack: ${error instanceof Error ? error.stack : "N/A"}
`,
    });

    throw error; // Re-throw after capturing
  }
});
```

## Graceful Degradation

Continue workflow even if non-critical steps fail:

```typescript
await step.phase("post-build", async () => {
  // Critical step - must succeed
  await step.cli("deploy", {
    command: "npm run deploy",
  });

  // Optional step - failure is OK
  try {
    await step.cli("notify-slack", {
      command: "curl -X POST $SLACK_WEBHOOK ...",
    });
  } catch (error) {
    await step.annotation("notification-failed", {
      message: "Slack notification failed (non-critical)",
    });
    // Don't re-throw - continue workflow
  }

  // Another critical step
  await step.cli("health-check", {
    command: "curl https://app.example.com/health",
  });
});
```

## Conditional Recovery

Recover from specific error types:

```typescript
await step.phase("build", async () => {
  try {
    await step.cli("build", {
      command: "npm run build",
    });
  } catch (error) {
    const errorMessage = String(error);

    if (errorMessage.includes("ENOSPC")) {
      // Disk space error - clean and retry
      await step.annotation("cleanup", {
        message: "Disk full, cleaning cache...",
      });

      await step.cli("clean", {
        command: "npm run clean && rm -rf node_modules/.cache",
      });

      // Retry build
      await step.cli("build-retry", {
        command: "npm run build",
      });
    } else if (errorMessage.includes("MODULE_NOT_FOUND")) {
      // Missing dependencies
      await step.annotation("reinstall", {
        message: "Dependencies missing, reinstalling...",
      });

      await step.cli("install", {
        command: "npm ci",
      });

      // Retry build
      await step.cli("build-retry", {
        command: "npm run build",
      });
    } else {
      // Unknown error - fail
      throw error;
    }
  }
});
```

## Phase-Level Error Handling

Handle errors at the workflow level to control overall flow:

```typescript
export default defineWorkflow(
  {
    id: "resilient-workflow",
    phases: ["build", "test", "deploy"],
  },
  async ({ event, step }) => {
    interface Context {
      buildSucceeded: boolean;
      testSucceeded: boolean;
      deploySucceeded: boolean;
    }
    const ctx: Context = {
      buildSucceeded: false,
      testSucceeded: false,
      deploySucceeded: false,
    };

    // Build phase
    try {
      await step.phase("build", async () => {
        await step.cli("build", { command: "npm run build" });
      });
      ctx.buildSucceeded = true;
    } catch (error) {
      await step.annotation("build-failed", {
        message: `Build failed: ${error}`,
      });
      // Don't return - continue to report all failures
    }

    // Test phase - only if build succeeded
    if (ctx.buildSucceeded) {
      try {
        await step.phase("test", async () => {
          await step.cli("test", { command: "npm test" });
        });
        ctx.testSucceeded = true;
      } catch (error) {
        await step.annotation("test-failed", {
          message: `Tests failed: ${error}`,
        });
      }
    }

    // Deploy phase - only if build and test succeeded
    if (ctx.buildSucceeded && ctx.testSucceeded) {
      try {
        await step.phase("deploy", async () => {
          await step.cli("deploy", { command: "npm run deploy" });
        });
        ctx.deploySucceeded = true;
      } catch (error) {
        await step.annotation("deploy-failed", {
          message: `Deploy failed: ${error}`,
        });
      }
    }

    // Return summary
    return {
      success: ctx.deploySucceeded,
      summary: ctx,
    };
  }
);
```

## Validation Errors

Handle argument validation failures:

```typescript
export default defineWorkflow(
  {
    id: "validated-workflow",
    argsSchema: defineSchema({
      type: "object",
      properties: {
        environment: { enum: ["dev", "staging", "prod"] },
      },
      required: ["environment"],
    }),
  },
  async ({ event, step }) => {
    const { environment } = event.data.args;

    // Additional runtime validation
    if (environment === "prod") {
      const approvalRequired = event.data.requiresApproval;

      if (!approvalRequired) {
        throw new Error(
          "Production deployments require manual approval"
        );
      }
    }

    await step.phase("deploy", async () => {
      await step.cli("deploy", {
        command: `npm run deploy:${environment}`,
      });
    });
  }
);
```

<Callout type="info">
**JSON Schema Validation**: Arguments are validated automatically before the workflow runs. Custom validation can be added in the workflow function.
</Callout>

## Best Practices

### Always Re-throw Critical Errors

```typescript
// ✅ Good - re-throw after logging
try {
  await step.cli("critical-step", { ... });
} catch (error) {
  await step.artifact("error", { ... });
  throw error; // Fail the workflow
}

// ❌ Avoid - swallowing critical errors
try {
  await step.cli("critical-step", { ... });
} catch (error) {
  console.error(error); // Error is lost
}
```

### Use Annotations for Visibility

```typescript
// ✅ Good - clear progress tracking
try {
  await step.annotation("starting", { message: "Building..." });
  await step.cli("build", { ... });
  await step.annotation("success", { message: "Build succeeded" });
} catch (error) {
  await step.annotation("failed", { message: `Build failed: ${error}` });
  throw error;
}
```

### Set Appropriate Timeouts

```typescript
// ✅ Good - timeout matches expected duration
await step.cli("quick-lint", {
  command: "npm run lint",
}, {
  timeout: 30000, // 30s for fast linting
});

await step.agent("code-review", {
  agent: "claude",
  prompt: "Review all changes",
}, {
  timeout: 600000, // 10min for thorough review
});
```

### Capture Error Context

```typescript
// ✅ Good - rich error context
catch (error) {
  await step.artifact("error-context", {
    name: "error.json",
    type: "text",
    content: JSON.stringify({
      error: String(error),
      stack: error instanceof Error ? error.stack : undefined,
      timestamp: new Date().toISOString(),
      phase: "build",
      step: "compile",
      context: { buildType: "production" },
    }, null, 2),
  });
}
```

## Next Steps

- [Workflow Definition](/docs/guides/workflow-definition) - Back to basics
- [Context Sharing](/docs/guides/context-sharing) - Share error state between phases
- [CLI Step](/docs/reference/steps/cli) - CLI command configuration
