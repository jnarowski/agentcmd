---
title: Basic Automation
description: End-to-end automation workflows for common development tasks
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';

Build workflows that automate repetitive development tasks like updating version numbers, formatting code, generating changelogs, and committing changes to git.

## Overview

Basic automation workflows follow a simple pattern:

1. **Read** - Load current state from files or git
2. **Transform** - Apply changes with AI or CLI tools
3. **Write** - Save results back to files
4. **Commit** - Track changes in version control

## Simple Example

Automate code formatting across a project:

```typescript
import { defineWorkflow } from 'agentcmd-workflows';

export default defineWorkflow({
  id: 'format-code',
  phases: ['format', 'commit']
}, async ({ event, step }) => {
  const { workingDir } = event.data;

  await step.phase('format', async () => {
    await step.cli('prettier', {
      command: 'npx prettier --write "src/**/*.{ts,tsx}"',
      cwd: workingDir
    });
  });

  await step.phase('commit', async () => {
    await step.git('commit-changes', {
      operation: 'commit',
      message: 'style: format code with prettier'
    });
  });
});
```

## Focused Example

Update version numbers across multiple files:

```typescript
import { defineWorkflow, defineSchema } from 'agentcmd-workflows';

const argsSchema = defineSchema({
  type: 'object',
  properties: {
    newVersion: { type: 'string' },
    updateChangelog: { type: 'boolean' }
  },
  required: ['newVersion']
});

type WorkflowArgs = {
  newVersion: string;
  updateChangelog?: boolean;
};

export default defineWorkflow(
  {
    id: 'bump-version',
    phases: ['read', 'update', 'commit'],
    argsSchema
  },
  async ({ event, step }) => {
    const args = event.data.args as unknown as WorkflowArgs;
    const { workingDir } = event.data;
    const { newVersion, updateChangelog = true } = args;

    interface Context {
      currentVersion?: string;
      filesUpdated: string[];
    }
    const ctx: Context = {
      filesUpdated: []
    };

    await step.phase('read', async () => {
      const pkgResult = await step.cli('read-package', {
        command: 'cat package.json',
        cwd: workingDir
      });

      const pkg = JSON.parse(pkgResult.data.stdout || '{}');
      ctx.currentVersion = pkg.version;

      step.log(`Current version: ${ctx.currentVersion}`);
      step.log(`New version: ${newVersion}`);
    });

    await step.phase('update', async () => {
      // Update package.json
      await step.cli('update-package', {
        command: `npm version ${newVersion} --no-git-tag-version`,
        cwd: workingDir
      });
      ctx.filesUpdated.push('package.json');

      // Update README if version mentioned
      const readmeResult = await step.cli('check-readme', {
        command: `grep -q "${ctx.currentVersion}" README.md && echo "found" || echo "not-found"`,
        cwd: workingDir
      });

      if (readmeResult.data.stdout?.trim() === 'found') {
        await step.cli('update-readme', {
          command: `sed -i '' 's/${ctx.currentVersion}/${newVersion}/g' README.md`,
          cwd: workingDir
        });
        ctx.filesUpdated.push('README.md');
      }

      // Update CHANGELOG.md
      if (updateChangelog) {
        const date = new Date().toISOString().split('T')[0];
        const entry = `\n## [${newVersion}] - ${date}\n\n### Changed\n- Version bump to ${newVersion}\n`;

        await step.cli('update-changelog', {
          command: `echo "${entry}$(cat CHANGELOG.md)" > CHANGELOG.md`,
          cwd: workingDir
        });
        ctx.filesUpdated.push('CHANGELOG.md');
      }

      step.log('Updated files:', ctx.filesUpdated);
    });

    await step.phase('commit', async () => {
      await step.git('commit-version', {
        operation: 'commit',
        message: `chore: bump version to ${newVersion}\n\nUpdated:\n${ctx.filesUpdated.map(f => `- ${f}`).join('\n')}`
      });
    });

    return {
      success: true,
      version: newVersion,
      filesUpdated: ctx.filesUpdated
    };
  }
);
```

## Production Example

Complete changelog automation with git history analysis:

```typescript
import { defineWorkflow, defineSchema } from 'agentcmd-workflows';
import { z } from 'zod';

const argsSchema = defineSchema({
  type: 'object',
  properties: {
    version: { type: 'string' },
    since: { type: 'string' },
    includeBreaking: { type: 'boolean' }
  },
  required: ['version']
});

type WorkflowArgs = {
  version: string;
  since?: string;
  includeBreaking?: boolean;
};

const changelogSchema = z.object({
  version: z.string(),
  date: z.string(),
  sections: z.object({
    breaking: z.array(z.string()).optional(),
    features: z.array(z.string()),
    fixes: z.array(z.string()),
    chores: z.array(z.string()),
    docs: z.array(z.string())
  }),
  contributors: z.array(z.string())
});

type ChangelogData = z.infer<typeof changelogSchema>;

export default defineWorkflow(
  {
    id: 'generate-changelog',
    name: 'Generate Changelog',
    description: 'Automatically generate changelog from git history',
    phases: [
      { id: 'collect', label: 'Collect Changes' },
      { id: 'analyze', label: 'Analyze Commits' },
      { id: 'generate', label: 'Generate Changelog' },
      { id: 'finalize', label: 'Finalize & Commit' }
    ],
    argsSchema
  },
  async ({ event, step }) => {
    const args = event.data.args as unknown as WorkflowArgs;
    const { workingDir } = event.data;
    const { version, since = '2 weeks ago', includeBreaking = true } = args;

    interface Context {
      commits?: string;
      currentChangelog?: string;
      changelogData?: ChangelogData;
      newChangelog?: string;
    }
    const ctx: Context = {};

    // ========================================================================
    // COLLECT PHASE
    // ========================================================================

    await step.phase('collect', async () => {
      await step.annotation('collect-start', {
        message: `Collecting commits since: ${since}`
      });

      // Get commit history
      const commitsResult = await step.cli('get-commits', {
        command: `git log --pretty=format:"%h - %s (%an)" --since="${since}"`,
        cwd: workingDir
      });

      ctx.commits = commitsResult.data.stdout || '';

      if (!ctx.commits) {
        throw new Error('No commits found in specified range');
      }

      step.log(`Found commits:\n${ctx.commits}`);

      // Read existing changelog
      const changelogResult = await step.cli('read-changelog', {
        command: 'cat CHANGELOG.md || echo "# Changelog\n\nAll notable changes to this project will be documented in this file."',
        cwd: workingDir
      });

      ctx.currentChangelog = changelogResult.data.stdout || '';
    });

    // ========================================================================
    // ANALYZE PHASE
    // ========================================================================

    await step.phase('analyze', async () => {
      await step.annotation('analyze-start', {
        message: 'Analyzing commits with AI'
      });

      const analysisPrompt = `Analyze these git commits and categorize them:

${ctx.commits}

Categorize each commit into:
- breaking: Breaking changes (BREAKING CHANGE in commit)
- features: New features (feat:)
- fixes: Bug fixes (fix:)
- chores: Chores (chore:)
- docs: Documentation (docs:)

Extract contributor names from commit authors.

Return structured JSON with the changelog data.`;

      const result = await step.ai<ChangelogData>('analyze-commits', {
        prompt: analysisPrompt,
        schema: changelogSchema,
        provider: 'anthropic',
        model: 'claude-sonnet-4-5-20250929'
      });

      ctx.changelogData = {
        ...result.data,
        version,
        date: new Date().toISOString().split('T')[0]
      };

      step.log('Changelog data:', ctx.changelogData);

      // Filter out breaking changes if not included
      if (!includeBreaking) {
        delete ctx.changelogData.sections.breaking;
      }
    });

    // ========================================================================
    // GENERATE PHASE
    // ========================================================================

    await step.phase('generate', async () => {
      if (!ctx.changelogData) throw new Error('No changelog data');

      await step.annotation('generate-start', {
        message: 'Generating changelog markdown'
      });

      const sections = ctx.changelogData.sections;
      const parts: string[] = [];

      parts.push(`## [${ctx.changelogData.version}] - ${ctx.changelogData.date}`);
      parts.push('');

      if (sections.breaking && sections.breaking.length > 0) {
        parts.push('### ⚠️ BREAKING CHANGES');
        parts.push('');
        sections.breaking.forEach(item => parts.push(`- ${item}`));
        parts.push('');
      }

      if (sections.features.length > 0) {
        parts.push('### Features');
        parts.push('');
        sections.features.forEach(item => parts.push(`- ${item}`));
        parts.push('');
      }

      if (sections.fixes.length > 0) {
        parts.push('### Bug Fixes');
        parts.push('');
        sections.fixes.forEach(item => parts.push(`- ${item}`));
        parts.push('');
      }

      if (sections.chores.length > 0) {
        parts.push('### Chores');
        parts.push('');
        sections.chores.forEach(item => parts.push(`- ${item}`));
        parts.push('');
      }

      if (sections.docs.length > 0) {
        parts.push('### Documentation');
        parts.push('');
        sections.docs.forEach(item => parts.push(`- ${item}`));
        parts.push('');
      }

      if (ctx.changelogData.contributors.length > 0) {
        parts.push('### Contributors');
        parts.push('');
        parts.push(`Thanks to ${ctx.changelogData.contributors.join(', ')} for contributions to this release!`);
        parts.push('');
      }

      const newEntry = parts.join('\n');

      // Prepend to existing changelog
      const lines = ctx.currentChangelog!.split('\n');
      const headerEndIndex = lines.findIndex((line, i) =>
        i > 0 && line.startsWith('##')
      );

      if (headerEndIndex > 0) {
        lines.splice(headerEndIndex, 0, newEntry);
        ctx.newChangelog = lines.join('\n');
      } else {
        ctx.newChangelog = `${ctx.currentChangelog}\n\n${newEntry}`;
      }

      await step.artifact('changelog-preview', {
        name: 'changelog-preview.md',
        type: 'text',
        content: newEntry,
        description: 'Preview of new changelog entry'
      });
    });

    // ========================================================================
    // FINALIZE PHASE
    // ========================================================================

    await step.phase('finalize', async () => {
      if (!ctx.newChangelog) throw new Error('No changelog generated');

      // Write changelog
      await step.cli('write-changelog', {
        command: `cat > CHANGELOG.md << 'EOF'\n${ctx.newChangelog}\nEOF`,
        cwd: workingDir
      });

      step.log('Changelog updated');

      // Commit changes
      await step.git('commit-changelog', {
        operation: 'commit',
        message: `docs: update changelog for v${version}

Generated from commits since ${since}.

${ctx.changelogData!.contributors.length} contributors.`
      });

      await step.annotation('finalize-complete', {
        message: `Changelog generated and committed for v${version}`
      });
    });

    // ========================================================================
    // RETURN RESULT
    // ========================================================================

    return {
      success: true,
      version,
      entriesAdded: {
        breaking: ctx.changelogData?.sections.breaking?.length || 0,
        features: ctx.changelogData?.sections.features.length || 0,
        fixes: ctx.changelogData?.sections.fixes.length || 0,
        chores: ctx.changelogData?.sections.chores.length || 0,
        docs: ctx.changelogData?.sections.docs.length || 0
      },
      contributors: ctx.changelogData?.contributors.length || 0
    };
  }
);
```

## Running Workflows

<Tabs items={['CLI', 'Programmatic']}>
<Tab value="CLI">
```bash
# Format code
agentcmd run format-code

# Bump version
agentcmd run bump-version --newVersion "2.1.0" --updateChangelog true

# Generate changelog
agentcmd run generate-changelog \
  --version "2.0.0" \
  --since "1 month ago" \
  --includeBreaking true

# Dry run to preview
agentcmd run generate-changelog \
  --version "2.0.0" \
  --dry-run
```
</Tab>
<Tab value="Programmatic">
```typescript
import { runWorkflow } from 'agentcmd-workflows';
import changelogWorkflow from './.agent/workflows/definitions/generate-changelog';

const result = await runWorkflow(changelogWorkflow, {
  args: {
    version: '2.0.0',
    since: '1 month ago',
    includeBreaking: true
  },
  projectPath: process.cwd()
});

console.log('Changelog generated:', result);
```
</Tab>
</Tabs>

## Best Practices

### Use Git to Track State

Always commit changes to preserve history:

```typescript
await step.phase('finalize', async () => {
  await step.git('commit', {
    operation: 'commit',
    message: 'chore: automated update via workflow'
  });
});
```

### Validate Before Making Changes

Check current state before transforming:

```typescript
await step.phase('validate', async () => {
  const result = await step.cli('check-git-status', {
    command: 'git status --porcelain',
    cwd: workingDir
  });

  if (result.data.stdout?.trim()) {
    throw new Error('Working directory has uncommitted changes');
  }
});
```

### Create Artifacts for Debugging

Upload intermediate results:

```typescript
await step.artifact('debug-output', {
  name: 'workflow-state.json',
  type: 'text',
  content: JSON.stringify({
    timestamp: new Date().toISOString(),
    context: ctx,
    args: args
  }, null, 2)
});
```

### Handle File Existence

Check files exist before reading:

```typescript
const checkResult = await step.cli('check-file', {
  command: 'test -f README.md && echo "exists" || echo "missing"',
  cwd: workingDir
});

if (checkResult.data.stdout?.trim() === 'exists') {
  // Safe to read
  await step.cli('read-file', {
    command: 'cat README.md',
    cwd: workingDir
  });
}
```

## Common Pitfalls

<Callout type="warning">
**Avoid these mistakes:**

1. **Not checking git status** - Verify clean working directory
2. **Hardcoded file paths** - Use relative paths with `workingDir`
3. **No rollback plan** - Commit frequently to enable rollback
4. **Forgetting error artifacts** - Upload context on failures
5. **Skipping validation** - Validate inputs before processing
</Callout>

## Advanced Patterns

### Conditional File Updates

Update files only if they match criteria:

```typescript
const files = ['README.md', 'docs/guide.md', 'CONTRIBUTING.md'];

for (const file of files) {
  const checkResult = await step.cli(`check-${file}`, {
    command: `grep -q "v${currentVersion}" ${file} && echo "found" || echo "not-found"`,
    cwd: workingDir
  });

  if (checkResult.data.stdout?.trim() === 'found') {
    await step.cli(`update-${file}`, {
      command: `sed -i '' 's/v${currentVersion}/v${newVersion}/g' ${file}`,
      cwd: workingDir
    });
    ctx.filesUpdated.push(file);
  }
}
```

### Batch Processing

Process multiple items efficiently:

```typescript
const files = ['file1.ts', 'file2.ts', 'file3.ts'];
const batchSize = 10;

for (let i = 0; i < files.length; i += batchSize) {
  const batch = files.slice(i, i + batchSize);

  await step.cli(`format-batch-${i}`, {
    command: `npx prettier --write ${batch.join(' ')}`,
    cwd: workingDir
  });

  step.log(`Formatted batch ${i / batchSize + 1}`);
}
```

### Atomic Operations

Use git for atomic file updates:

```typescript
await step.git('atomic-update', {
  operation: 'commit-and-branch',
  commitMessage: 'feat: automated update',
  branch: 'auto-update',
  baseBranch: 'main'
});

// If workflow fails here, changes are isolated in branch
```

## Monitoring

Track workflow execution:

```bash
# View workflow runs
agentcmd workflows list

# Get detailed logs
agentcmd workflows logs <run-id>

# Download artifacts
agentcmd workflows artifacts <run-id> --download ./output
```

## Next Steps

- [Spec Implementation](/docs/examples/spec-implementation) - Implement features from specs
- [Data Processing](/docs/examples/data-processing) - Process data with AI
- [Context Sharing](/docs/guides/context-sharing) - Share data between phases
- [Error Handling](/docs/guides/error-handling) - Handle failures gracefully
