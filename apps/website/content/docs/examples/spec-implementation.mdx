---
title: Spec Implementation
description: Complete workflow for implementing features from specifications with AI agents
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';

Build a complete workflow that reads a specification document, implements the feature with AI assistance, reviews the implementation, and creates a pull request.

## Overview

Spec-driven development with AgentCmd follows this pattern:

1. **Analyze** - Read and parse the specification
2. **Implement** - AI agent implements features per spec
3. **Review** - Automated review against spec requirements
4. **Deploy** - Create PR with implementation

## Simple Example

Start with a basic spec implementation:

```typescript
import { defineWorkflow, buildSlashCommand } from 'agentcmd-workflows';

export default defineWorkflow({
  id: 'implement-spec-simple',
  phases: ['implement']
}, async ({ event, step }) => {
  const { specFile } = event.data;

  await step.phase('implement', async () => {
    await step.agent('implement', {
      agent: 'claude',
      prompt: buildSlashCommand('/cmd:implement-spec', {
        specIdOrNameOrPath: specFile,
        format: 'text'
      })
    });
  });
});
```

<Callout type="info">
`buildSlashCommand()` generates properly formatted slash command prompts with type-safe arguments.
</Callout>

## Focused Example

Add review and git integration:

```typescript
import {
  defineWorkflow,
  buildSlashCommand,
  type CmdImplementSpecResponse,
  type CmdReviewSpecImplementationResponse
} from 'agentcmd-workflows';

export default defineWorkflow({
  id: 'implement-and-review',
  phases: ['implement', 'review', 'pr']
}, async ({ event, step }) => {
  const { workingDir, specFile } = event.data;

  // Shared context
  interface Context {
    implementationResult?: CmdImplementSpecResponse;
    reviewResult?: CmdReviewSpecImplementationResponse;
    branch?: string;
  }
  const ctx: Context = {};

  await step.phase('implement', async () => {
    const result = await step.agent<CmdImplementSpecResponse>(
      'implement-spec',
      {
        agent: 'claude',
        json: true,
        prompt: buildSlashCommand('/cmd:implement-spec', {
          specIdOrNameOrPath: specFile,
          format: 'json'
        }),
        workingDir
      }
    );

    ctx.implementationResult = result.data;
    step.log('Implementation complete:', ctx.implementationResult);
  });

  await step.phase('review', async () => {
    const result = await step.agent<CmdReviewSpecImplementationResponse>(
      'review-implementation',
      {
        agent: 'claude',
        json: true,
        prompt: buildSlashCommand('/cmd:review-spec-implementation', {
          specIdOrNameOrPath: specFile,
          format: 'json'
        }),
        workingDir
      }
    );

    ctx.reviewResult = result.data;

    if (ctx.reviewResult.issues && ctx.reviewResult.issues.length > 0) {
      step.log.warn('Review found issues:', ctx.reviewResult.issues);
    }
  });

  await step.phase('pr', async () => {
    // Create branch and commit
    const branchName = `feat/${specFile.replace(/\//g, '-')}`;
    ctx.branch = branchName;

    await step.git('commit-and-branch', {
      operation: 'commit-and-branch',
      commitMessage: `feat: implement ${specFile}`,
      branch: branchName,
      baseBranch: 'main'
    });

    step.log('Ready for PR on branch:', ctx.branch);
  });

  return {
    success: true,
    implementation: ctx.implementationResult,
    review: ctx.reviewResult,
    branch: ctx.branch
  };
});
```

## Production Example

Complete workflow with error handling, retries, and quality gates:

```typescript
import {
  defineWorkflow,
  buildSlashCommand,
  defineSchema,
  type CmdImplementSpecResponse,
  type CmdReviewSpecImplementationResponse,
} from 'agentcmd-workflows';

// Define typed arguments
const argsSchema = defineSchema({
  type: 'object',
  properties: {
    specId: { type: 'string' },
    skipTests: { type: 'boolean' },
    createPr: { type: 'boolean' },
    baseBranch: { type: 'string' }
  },
  required: ['specId']
});

type WorkflowArgs = {
  specId: string;
  skipTests?: boolean;
  createPr?: boolean;
  baseBranch?: string;
};

export default defineWorkflow(
  {
    id: 'spec-implementation-production',
    name: 'Production Spec Implementation',
    description: 'Full-featured spec implementation with quality gates',
    phases: [
      { id: 'analyze', label: 'Analyze Specification' },
      { id: 'implement', label: 'Implement Features' },
      { id: 'test', label: 'Run Tests' },
      { id: 'review', label: 'Review Implementation' },
      { id: 'fix', label: 'Fix Issues' },
      { id: 'finalize', label: 'Finalize & PR' }
    ],
    argsSchema
  },
  async ({ event, step }) => {
    const args = event.data.args as unknown as WorkflowArgs;
    const { workingDir } = event.data;
    const { specId, skipTests = false, createPr = true, baseBranch = 'main' } = args;

    // Workflow context
    interface Context {
      specFile?: string;
      implementation?: CmdImplementSpecResponse;
      testResults?: {
        passed: boolean;
        output: string;
      };
      review?: CmdReviewSpecImplementationResponse;
      branch?: string;
      prUrl?: string;
      needsFixes: boolean;
    }
    const ctx: Context = {
      needsFixes: false
    };

    // ========================================================================
    // ANALYZE PHASE
    // ========================================================================

    await step.phase('analyze', async () => {
      await step.annotation('analyze-start', {
        message: `Analyzing specification: ${specId}`
      });

      // Read spec file to understand requirements
      const specResult = await step.cli('read-spec', {
        command: `cat .agent/specs/*/${specId}*/spec.md || find .agent/specs -name "${specId}*" -type f`,
        cwd: workingDir
      });

      if (specResult.data.exitCode !== 0) {
        throw new Error(`Spec file not found: ${specId}`);
      }

      ctx.specFile = specId;

      // Extract complexity estimate
      await step.artifact('spec-summary', {
        name: 'spec-analysis.txt',
        type: 'text',
        content: `Specification: ${specId}\n\n${specResult.data.stdout}`
      });

      step.log(`Spec loaded: ${ctx.specFile}`);
    });

    // ========================================================================
    // IMPLEMENT PHASE
    // ========================================================================

    await step.phase('implement', async () => {
      await step.annotation('implement-start', {
        message: 'Starting implementation with AI agent'
      });

      try {
        const result = await step.agent<CmdImplementSpecResponse>(
          'implement-spec',
          {
            agent: 'claude',
            json: true,
            prompt: buildSlashCommand('/cmd:implement-spec', {
              specIdOrNameOrPath: ctx.specFile!,
              format: 'json'
            }),
            workingDir,
            permissionMode: 'default'
          }
        );

        ctx.implementation = result.data;

        await step.artifact('implementation-summary', {
          name: 'implementation.json',
          type: 'text',
          content: JSON.stringify(ctx.implementation, null, 2)
        });

        step.log('Implementation completed:', {
          filesModified: ctx.implementation.filesModified?.length || 0,
          summary: ctx.implementation.summary
        });

      } catch (error) {
        step.log.error('Implementation failed:', error);

        await step.artifact('implementation-error', {
          name: 'implementation-error.txt',
          type: 'text',
          content: `Error during implementation:\n${error}\n\nStack:\n${(error as Error).stack}`
        });

        throw error;
      }
    });

    // ========================================================================
    // TEST PHASE
    // ========================================================================

    if (!skipTests) {
      await step.phase('test', async () => {
        await step.annotation('test-start', {
          message: 'Running test suite'
        });

        const testResult = await step.cli('run-tests', {
          name: 'Run Tests',
          command: 'npm test -- --run',
          cwd: workingDir,
          timeout: '10m'
        });

        ctx.testResults = {
          passed: testResult.data.exitCode === 0,
          output: testResult.data.stdout || ''
        };

        if (!ctx.testResults.passed) {
          step.log.warn('Tests failed:', ctx.testResults.output);
          ctx.needsFixes = true;

          await step.artifact('test-failures', {
            name: 'test-failures.txt',
            type: 'text',
            content: `Test Output:\n${ctx.testResults.output}\n\nStderr:\n${testResult.data.stderr}`
          });
        } else {
          step.log('All tests passed');
        }
      });
    } else {
      step.log('Skipping tests per workflow arguments');
    }

    // ========================================================================
    // REVIEW PHASE
    // ========================================================================

    await step.phase('review', async () => {
      await step.annotation('review-start', {
        message: 'Reviewing implementation against spec'
      });

      const result = await step.agent<CmdReviewSpecImplementationResponse>(
        'review-spec-implementation',
        {
          agent: 'claude',
          json: true,
          prompt: buildSlashCommand('/cmd:review-spec-implementation', {
            specIdOrNameOrPath: ctx.specFile!,
            format: 'json'
          }),
          workingDir,
          permissionMode: 'plan'
        }
      );

      ctx.review = result.data;

      await step.artifact('review-report', {
        name: 'review-report.json',
        type: 'text',
        content: JSON.stringify(ctx.review, null, 2)
      });

      if (ctx.review.issues && ctx.review.issues.length > 0) {
        step.log.warn(`Review found ${ctx.review.issues.length} issues:`, ctx.review.issues);
        ctx.needsFixes = true;
      } else {
        step.log('Review passed - no issues found');
      }
    });

    // ========================================================================
    // FIX PHASE (conditional)
    // ========================================================================

    if (ctx.needsFixes) {
      await step.phase('fix', async () => {
        await step.annotation('fix-start', {
          message: 'Fixing issues found during review/testing'
        });

        const fixPrompt = `Fix the following issues:

Test Failures:
${ctx.testResults?.passed === false ? ctx.testResults.output : 'No test failures'}

Review Issues:
${ctx.review?.issues?.map((issue, i) => `${i + 1}. ${issue}`).join('\n') || 'No review issues'}

Make minimal changes to fix these specific issues.`;

        await step.agent('fix-issues', {
          agent: 'claude',
          prompt: fixPrompt,
          workingDir,
          permissionMode: 'default'
        });

        // Re-run tests if they failed before
        if (ctx.testResults && !ctx.testResults.passed) {
          const retestResult = await step.cli('retest', {
            command: 'npm test -- --run',
            cwd: workingDir
          });

          if (retestResult.data.exitCode !== 0) {
            step.log.error('Tests still failing after fixes');
            throw new Error('Unable to fix failing tests');
          } else {
            step.log('Tests now passing after fixes');
          }
        }

        await step.annotation('fix-complete', {
          message: 'Issues fixed and verified'
        });
      });
    } else {
      step.log('Skipping fix phase - no issues found');
    }

    // ========================================================================
    // FINALIZE PHASE
    // ========================================================================

    await step.phase('finalize', async () => {
      const branchName = `feat/spec-${ctx.specFile!.replace(/[^a-z0-9]/gi, '-').toLowerCase()}`;
      ctx.branch = branchName;

      // Commit all changes
      await step.git('commit-changes', {
        operation: 'commit-and-branch',
        commitMessage: `feat: implement ${ctx.specFile}\n\n${ctx.implementation?.summary || 'Implementation per spec'}`,
        branch: branchName,
        baseBranch
      });

      step.log('Changes committed to branch:', ctx.branch);

      if (createPr) {
        // Build PR body
        const prBody = `## Implementation

Spec: \`${ctx.specFile}\`

${ctx.implementation?.summary || 'Implemented features per specification.'}

## Files Modified

${ctx.implementation?.filesModified?.map(f => `- \`${f}\``).join('\n') || 'No files tracked'}

## Test Results

${ctx.testResults?.passed ? '✅ All tests passing' : '⚠️ Tests were skipped'}

## Review

${ctx.review?.issues?.length ? `⚠️ Found ${ctx.review.issues.length} issues (fixed in this PR)` : '✅ No issues found'}

---

Generated by AgentCmd workflow: \`${event.name}\``;

        const prResult = await step.git('create-pr', {
          operation: 'pr',
          title: `feat: ${ctx.specFile}`,
          body: prBody,
          branch: branchName,
          baseBranch
        });

        ctx.prUrl = prResult.data.prUrl;

        await step.annotation('pr-created', {
          message: `Pull request created: ${ctx.prUrl}`
        });

        step.log('PR created:', ctx.prUrl);
      } else {
        step.log('Skipping PR creation per workflow arguments');
      }
    });

    // ========================================================================
    // WORKFLOW RESULT
    // ========================================================================

    return {
      success: true,
      spec: ctx.specFile,
      filesModified: ctx.implementation?.filesModified,
      testsPassed: ctx.testResults?.passed ?? null,
      reviewIssues: ctx.review?.issues?.length ?? 0,
      branch: ctx.branch,
      prUrl: ctx.prUrl
    };
  }
);
```

## Running the Workflow

<Tabs items={['CLI', 'Programmatic']}>
<Tab value="CLI">
```bash
# Basic usage
agentcmd run spec-implementation-production --specId "001-auth-feature"

# Skip tests
agentcmd run spec-implementation-production \
  --specId "002-dashboard" \
  --skipTests true

# Custom base branch
agentcmd run spec-implementation-production \
  --specId "003-api" \
  --baseBranch "develop" \
  --createPr true

# Dry run
agentcmd run spec-implementation-production \
  --specId "004-refactor" \
  --dry-run
```
</Tab>
<Tab value="Programmatic">
```typescript
import { runWorkflow } from 'agentcmd-workflows';
import specWorkflow from './.agent/workflows/definitions/spec-implementation-production';

const result = await runWorkflow(specWorkflow, {
  args: {
    specId: '001-auth-feature',
    skipTests: false,
    createPr: true,
    baseBranch: 'main'
  },
  projectPath: process.cwd()
});

console.log('Workflow result:', result);
```
</Tab>
</Tabs>

## Best Practices

### Use JSON Mode for Structured Data

Extract structured responses from agents:

```typescript
interface ImplementationResult {
  filesModified: string[];
  summary: string;
  complexity: number;
}

const result = await step.agent<ImplementationResult>('implement', {
  agent: 'claude',
  json: true, // Enable JSON extraction
  prompt: buildSlashCommand('/cmd:implement-spec', {
    specIdOrNameOrPath: specFile,
    format: 'json'
  })
});

// result.data is typed as ImplementationResult
console.log(result.data.filesModified);
```

### Validate Context Before Use

Always check context exists before accessing:

```typescript
await step.phase('review', async () => {
  if (!ctx.specFile) {
    throw new Error('No spec file found from analyze phase');
  }

  if (!ctx.implementation) {
    throw new Error('No implementation result from implement phase');
  }

  // Safe to use
  await step.agent('review', {
    prompt: `Review ${ctx.specFile}`
  });
});
```

### Create Artifacts for Debugging

Upload key outputs as artifacts:

```typescript
await step.artifact('implementation-details', {
  name: 'implementation.json',
  type: 'text',
  content: JSON.stringify({
    spec: ctx.specFile,
    files: ctx.implementation.filesModified,
    timestamp: new Date().toISOString()
  }, null, 2),
  description: 'Implementation details for debugging'
});
```

### Handle Partial Failures Gracefully

Don't fail entire workflow for non-critical steps:

```typescript
await step.phase('notify', async () => {
  try {
    await step.cli('send-notification', {
      command: `curl -X POST ${webhookUrl} -d '{"message": "Deploy complete"}'`
    });
  } catch (error) {
    step.log.warn('Notification failed (non-critical):', error);
    // Don't re-throw - continue workflow
  }
});
```

## Common Pitfalls

<Callout type="warning">
**Avoid these common mistakes:**

1. **Not checking spec file exists** - Always validate file paths before using
2. **Skipping test verification** - Run tests even in automated workflows
3. **Missing error artifacts** - Upload error details for debugging
4. **Hardcoded branch names** - Derive from spec ID for uniqueness
5. **No retry logic** - Use Inngest's built-in retry for flaky steps
</Callout>

## Advanced Patterns

### Parallel Implementation

Implement multiple independent specs simultaneously:

```typescript
await step.phase('implement', async () => {
  const specs = ['spec-1', 'spec-2', 'spec-3'];

  // Run in parallel using Promise.all
  const results = await Promise.all(
    specs.map((specId, index) =>
      step.agent(`implement-${index}`, {
        agent: 'claude',
        prompt: buildSlashCommand('/cmd:implement-spec', {
          specIdOrNameOrPath: specId,
          format: 'json'
        }),
        json: true
      })
    )
  );

  step.log('All specs implemented:', results.length);
});
```

### Conditional Review Depth

Adjust review depth based on complexity:

```typescript
await step.phase('review', async () => {
  const isComplex = ctx.implementation.complexity > 7;

  const reviewPrompt = buildSlashCommand('/cmd:review-spec-implementation', {
    specIdOrNameOrPath: ctx.specFile,
    format: 'json'
  });

  if (isComplex) {
    // Deep review for complex changes
    await step.agent('deep-review', {
      agent: 'claude',
      prompt: `${reviewPrompt}\n\nPerform an in-depth review with security analysis.`,
      json: true
    });
  } else {
    // Quick review for simple changes
    await step.agent('quick-review', {
      agent: 'claude',
      prompt: reviewPrompt,
      json: true,
      permissionMode: 'plan'
    });
  }
});
```

## Monitoring & Debugging

Track workflow execution:

```bash
# List recent workflow runs
agentcmd workflows list

# View detailed logs
agentcmd workflows logs <run-id>

# View specific phase logs
agentcmd workflows logs <run-id> --phase implement

# Download artifacts
agentcmd workflows artifacts <run-id> --download ./output
```

## Next Steps

- [Data Processing](/docs/examples/data-processing) - Process data with AI
- [Custom Slash Commands](/docs/examples/custom-slash-command) - Create reusable commands
- [Error Handling](/docs/guides/error-handling) - Advanced error patterns
- [Context Sharing](/docs/guides/context-sharing) - Share data between phases
