---
title: Type-Safe Arguments
description: Define and validate workflow inputs with JSON Schema
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

## Overview

Workflows can accept typed arguments using `argsSchema` and `defineSchema()`. This provides:

- Runtime validation via JSON Schema
- Automatic TypeScript type inference
- IDE autocomplete for event.data.args
- Clear documentation of required inputs

## Basic Usage

```typescript
import { defineWorkflow, defineSchema } from "agentcmd-workflows";

const argsSchema = defineSchema({
  type: "object",
  properties: {
    priority: { enum: ["critical", "high", "medium", "low"] },
    createPr: { type: "boolean" },
    runE2e: { type: "boolean" },
  },
  required: ["priority"],
});

export default defineWorkflow(
  {
    id: "my-workflow",
    argsSchema,
  },
  async ({ event, step }) => {
    // Fully typed!
    const { priority, createPr, runE2e } = event.data.args;
    //      ^"critical" | "high" | "medium" | "low"
    //                  ^boolean | undefined
    //                            ^boolean | undefined
  }
);
```

## Schema Definition

{/* AUTO-GENERATED:schema-builder-api */}
### defineSchema() API

The `defineSchema()` function captures literal types automatically (no `as const` needed):

```typescript
const schema = defineSchema({
  type: "object",
  properties: {
    buildType: { enum: ["production", "development"] },
    verbose: { type: "boolean" },
  },
  required: ["buildType"],
});

type Inferred = InferSchemaType<typeof schema>;
// { buildType: "production" | "development", verbose?: boolean }
```

### Supported JSON Schema Types

| Type | JSON Schema | TypeScript Type |
|------|-------------|-----------------|
| String | `{ type: "string" }` | `string` |
| Number | `{ type: "number" }` | `number` |
| Boolean | `{ type: "boolean" }` | `boolean` |
| Enum | `{ enum: ["a", "b"] }` | `"a" \| "b"` |
| Object | `{ type: "object", properties: {...} }` | `{ ... }` |
| Array | `{ type: "array", items: {...} }` | `T[]` |

{/* /AUTO-GENERATED:schema-builder-api */}

## Examples

<Tabs items={['Simple', 'With Booleans', 'Full Example']}>
  <Tab value="Simple">
    ```typescript
    const argsSchema = defineSchema({
      type: "object",
      properties: {
        priority: { enum: ["critical", "high", "medium", "low"] },
      },
      required: ["priority"],
    });

    // Inferred type:
    // { priority: "critical" | "high" | "medium" | "low" }
    ```
  </Tab>

  <Tab value="With Booleans">
    ```typescript
    const argsSchema = defineSchema({
      type: "object",
      properties: {
        priority: { enum: ["critical", "high", "medium", "low"] },
        createPr: { type: "boolean" },
      },
      required: ["priority"],
    });

    // Inferred type:
    // {
    //   priority: "critical" | "high" | "medium" | "low",
    //   createPr?: boolean
    // }
    ```
  </Tab>

  <Tab value="Full Example">
    ```typescript
    const argsSchema = defineSchema({
      type: "object",
      properties: {
        priority: { enum: ["critical", "high", "medium", "low"] },
        createPr: { type: "boolean" },
        runE2e: { type: "boolean" },
      },
      required: ["priority"],
    });

    // Inferred type:
    // {
    //   priority: "critical" | "high" | "medium" | "low",
    //   createPr?: boolean,
    //   runE2e?: boolean
    // }
    ```
  </Tab>
</Tabs>

## Validation

Arguments are validated at runtime before the workflow executes:

```typescript
// ✅ Valid
await inngest.send({
  name: "workflow/my-workflow",
  data: {
    args: {
      priority: "high",
      createPr: true,
      runE2e: false,
    },
  },
});

// ❌ Invalid - missing required field
await inngest.send({
  name: "workflow/my-workflow",
  data: {
    args: {
      createPr: true, // priority is required!
    },
  },
});
// Throws validation error before workflow runs
```

## No `as const` Required

Unlike typical TypeScript patterns, `defineSchema()` automatically captures literal types:

```typescript
// ❌ Old pattern (other libraries)
const schema = {
  type: "object",
  properties: {
    env: { enum: ["dev", "prod"] },
  },
} as const;

// ✅ AgentCmd pattern (automatic)
const schema = defineSchema({
  type: "object",
  properties: {
    env: { enum: ["dev", "prod"] }, // Automatically literal!
  },
});
```

This works because `defineSchema()` uses const generic parameters to preserve literal types.

## Accessing Arguments

Arguments are available via `event.data.args`:

```typescript
export default defineWorkflow(
  {
    id: "feature-workflow",
    argsSchema: defineSchema({
      type: "object",
      properties: {
        priority: { enum: ["critical", "high", "medium", "low"] },
        createPr: { type: "boolean" },
        runE2e: { type: "boolean" },
      },
      required: ["priority"],
    }),
  },
  async ({ event, step }) => {
    // Destructure with full type safety
    const { priority, createPr, runE2e } = event.data.args;

    await step.annotation("start", {
      message: `Starting ${priority} priority feature implementation`,
    });

    // Implement the feature
    await step.cli("implement", {
      command: "pnpm build",
    });

    // Conditionally create PR
    if (createPr) {
      await step.git("create-pr", {
        operation: "pr",
        title: `feat: ${priority} priority implementation`,
      });
    }

    // Conditionally run E2E tests
    if (runE2e) {
      await step.cli("test-e2e", {
        command: "pnpm test:e2e",
      });
    }
  }
);
```

## Best Practices

### Use Enums for Fixed Choices

```typescript
// ✅ Good - type-safe enum
properties: {
  mode: { enum: ["auto", "manual"] }
}

// ❌ Avoid - loose string
properties: {
  mode: { type: "string" }
}
```

### Mark Required Fields Explicitly

```typescript
// ✅ Clear
{
  properties: {
    name: { type: "string" },
    email: { type: "string" },
  },
  required: ["name", "email"]
}

// ❌ Ambiguous
{
  properties: {
    name: { type: "string" },
    email: { type: "string" },
  }
}
```

### Provide Defaults in Code

JSON Schema doesn't support defaults well, so handle them in your workflow:

```typescript
async ({ event, step }) => {
  const { priority, createPr = false, runE2e = false } = event.data.args;
  // Now createPr and runE2e have defaults if not provided
}
```

## Type Inference Utilities

{/* AUTO-GENERATED:type-utilities-api */}
### InferSchemaType

Extract TypeScript types from schema:

```typescript
import type { InferSchemaType } from "agentcmd-workflows";

const schema = defineSchema({
  type: "object",
  properties: {
    name: { type: "string" },
  },
  required: ["name"],
});

type Args = InferSchemaType<typeof schema>;
// { name: string }
```

{/* /AUTO-GENERATED:type-utilities-api */}

## Next Steps

- [Context Sharing](/docs/examples/context-sharing) - Share data between phases
- [Type-Safe Slash Commands](/docs/examples/type-safe-slash-commands) - Build reusable workflow commands
- [Workflow Definition](/docs/concepts/workflows/workflow-definitions) - Back to basics
